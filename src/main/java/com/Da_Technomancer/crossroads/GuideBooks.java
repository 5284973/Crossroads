package com.Da_Technomancer.crossroads;

import java.awt.Color;
import java.util.ArrayList;
import java.util.LinkedHashMap;

import com.Da_Technomancer.crossroads.API.EnergyConverters;
import com.Da_Technomancer.crossroads.API.enums.GearTypes;
import com.Da_Technomancer.crossroads.API.enums.HeatConductors;
import com.Da_Technomancer.crossroads.API.enums.HeatInsulators;
import com.Da_Technomancer.crossroads.blocks.ModBlocks;
import com.Da_Technomancer.crossroads.items.ModItems;
import com.Da_Technomancer.crossroads.items.itemSets.GearFactory;
import com.Da_Technomancer.crossroads.items.itemSets.HeatCableFactory;

import amerifrance.guideapi.api.GuideAPI;
import amerifrance.guideapi.api.IPage;
import amerifrance.guideapi.api.impl.Book;
import amerifrance.guideapi.api.impl.Entry;
import amerifrance.guideapi.api.impl.Page;
import amerifrance.guideapi.api.impl.abstraction.CategoryAbstract;
import amerifrance.guideapi.api.impl.abstraction.EntryAbstract;
import amerifrance.guideapi.category.CategoryItemStack;
import amerifrance.guideapi.entry.EntryItemStack;
import amerifrance.guideapi.page.PageFurnaceRecipe;
import amerifrance.guideapi.page.PageIRecipe;
import amerifrance.guideapi.page.PageImage;
import amerifrance.guideapi.page.PageText;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.item.crafting.IRecipe;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.oredict.ShapedOreRecipe;
import net.minecraftforge.oredict.ShapelessOreRecipe;

public class GuideBooks{

	public static Book main = new Book();

	public static void mainGuide(FMLPreInitializationEvent e, boolean client){

		// Techno = normal (§r§r) use the double §r to make createPages() work
		// Witch = underline (§r§n)
		// Alchem = italic (§r§o)
		// Bobo = normal (§r§l)
		// The § symbol can be typed by holding alt and typing 0167 on the
		// numpad, then release alt.

		LinkedHashMap<ResourceLocation, EntryAbstract> entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();
		ArrayList<IPage> pages = new ArrayList<IPage>();
		ArrayList<CategoryAbstract> categories = new ArrayList<CategoryAbstract>();

		// INTRO
		createPages(pages, client, "§r§oAere yue suyre thys thyng ys wurckyng? §r§rYes I'm sure, I just turned it on and everything we're saying now is being recorded. §r§nThen stop talking you idiots and do the introduction! §r§rFine, then be quiet! Hello reader, I'm sure you are wondering what this book you have just found is. Let me explain. We are the three writers of this journal. §r§nWell obviously. §r§rBe Quiet. Anyways, at the time you are reading this we will be long gone. We each know the secrets of a different craft, and we are working together to record our knowledge for those in the future who would be capable of continuing our crafts. This journal will teach you the basics of magic and science so that you can make your decision as to which path to go down. I have worked with the other 2 writers to create a contraption that records what we say in this room into this journal, and will give a copy of this journal to capable people of the future, by making minor changes to reality. If you should ever need another copy of this book, just follow this recipe:", new ShapelessOreRecipe(Items.WRITTEN_BOOK, Items.BOOK, Items.COMPASS), "§r§rI know the secrets of Technomancy, manipulation of Time. Everything we say will be recorded in a different text style depending on the person. It was going to be different colors, but The Alchemist was worried the reader would be color blind. §r§oWait, what if the reader can't differentiate different fonts? §r§nThat's called being blind. §r§rJust introduce yourself. §r§oFine, I am an Alchemist. Alchemy is the manipulation of reality. §r§nThat leaves me. I am a witch. Witchcraft is the manipulation of void. Do not confuse true witchcraft with the silly villagers in pointy hats, they do no true witchcraft. §r§rWe won't tell you our names, for good reason. Basically, the three of us will teach you a bunch of mundane science and magic, and then we will have you choose: Witchcraft, Alchemy, or Technomancy. At that point you will recieve a new journal specifically about that art. You can only pick one, and you should wait to learn more from us before you make the decision. §r§nThat should wrap up this section then, so I just flip this switch to stop the machine, right? §r§rYep. §r§lhEloe mE es bObo! Me is no-er of the derp! Will teahc U durp like me! firSt lehson es pootato U muhst get dem 4 stuf! Beye now! §r§rWe just came back from lunch to find some idiot somehow got in and filled up the intro with badly spelled nonsense, with horrible grammer. Anyway, DO NOT TRUST anything this 'Bobo' person says, they seem like an idiot. Due to the nature of the machine, we can't remove this idiot's contribution. Just ignore it if he writes in any more stuff. §r§nHow do you know it's a he? §r§rI don't, people just automatically use he. §r§nFair enough.");
		entries.put(new ResourceLocation(Main.MODID, "intro"), new Entry(pages, "Introduction", true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBefore you can start making machines to progress, you'll need some ores you might not be used to using. There are 4 ores of interest. §r§nNot counting the normal stuff, like gold and redstone. §r§oHouw ys redftoen nurmel? Wat evin ys redftoen? §r§nDon't know, don't care. §r§rAnyways, the things to look out for are tin, copper, native copper, and rubies. Native Copper is very common, but is only found between y=50 & y=70. When broken, it gives 3 copper nuggets.", new ResourceLocation(Main.MODID + ":textures/blocks/oreNativeCopper.png"), "§r§rNormal Copper ore is also very common, and is only found below y=30. However, you'll need infrastructure to make it into ingots.", new ResourceLocation(Main.MODID + ":textures/blocks/oreCopper.png"), "§r§rTin ore is about as rare as gold, and is only found below y=30. It can be smelted into a tin ingot. Mine any that you find.", new ResourceLocation(Main.MODID + ":textures/blocks/oreTin.png"), "§r§rRuby ore is very rare, and is only found mixed in with quartz ore in the nether. It's only useful if you go into magic (NYI)", new ResourceLocation(Main.MODID + ":textures/blocks/oreRuby.png"), "§r§rCopper and tin can be made into blocks and nuggets with the normal recipe, and rubies can be made into blocks with the normal recipe. Also, copper and tin can be combined to make bronze, a useful alloy. Also, I should note how to make an axle.", new ShapedOreRecipe(Item.getByNameOrId(Main.MODID + ":ingotBronze"), "###", "#$#", "###", '#', "nuggetCopper", '$', "nuggetTin"), new ShapedOreRecipe(Item.getByNameOrId(Main.MODID + ":blockBronze"), "###", "#$#", "###", '#', "ingotCopper", '$', "ingotTin"), new ShapedOreRecipe(new ItemStack(ModItems.axle, 1), "#", "?", "#", '#', Blocks.STONE, '?', "ingotIron"));
		entries.put(new ResourceLocation(Main.MODID, "ores"), new Entry(pages, "Ores", true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBefore you can start using technology, you need to understand the power system. There are three main ways to transmit energy: Heat, Rotary, and Steam. Energy can be converted between the three forms in certain machines. This diagram shows the basic conversions:", new ResourceLocation(Main.MODID + ":textures/book/energyDiag.png"), "§r§rAs you can see from the diagram, once energy is converted to rotary form, you cannot change it back to heat. How exactly the energy is converted will be covered in later entries. A quick overview of each form of energy is that heat is simple, lossy, slow, and expensive to transfer, and is the main form of energy that you will generate. Steam is cheap, simple, lossless, and quick to transfer (making it ideal for transfering energy), and rotary is expensive, very fast, and complicated to transfer, and depending on how well you design your system could be very lossy or nearly lossless. Rotary is also the main type of energy you will be using for machines.");
		entries.put(new ResourceLocation(Main.MODID, "energy"), new Entry(pages, "Basics of Energy", true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§oThe most basic form of energy is heat. Heat is transmitted with heat cables. Heat cables average there temperture with that of things around them. There are two parts to each cable, the insulator and the conductor. The conductor determines the transfer rate, with a rate of one averaging fully every 10 ticks, and .5 avereging halfway every 10 ticks, and so on. The conductors are copper (.33), diamond (1), iron (.1), and quartz (.05). Iron and Quurtz are best for limiting the rate of heat transfer. The insulator determines 3 things: the rate of heat loss, the melting temperture of the cable, and what the cable dose when it melts. A loss rating of 1 means the temperture averages with the biome every 10 ticks, while a rating of .5 half averages every 10 ticks. The insulaters are wool, which burns at 300*, and has a loss of .01, slime, which re-animates at 500*, and has ae loss of .005, Ice melts at 0*, and is at -10* when first placed, but has the smallist loss off .00005. Finally, there is obsidean, which melts at 2000*, and has a loss of .0001. The cables are made in the same patern as this example:", new ShapedOreRecipe(new ItemStack(HeatCableFactory.cableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL), 4), "###", "$$$", "###", '#', Blocks.WOOL, '$', "ingotCopper"), "§r§oI should note that diamond cables are made with diamond wire instead of full diamonds. The wires are made like so:",new ShapedOreRecipe(new ItemStack(ModItems.diamondWire, 3), "*&*", '*', "ingotTin", '&', "gemDiamond"), "§r§oA useful tool is the thermometer, which measures the tempurture of a heat cable and is made as such:", new ShapedOreRecipe(new ItemStack(ModItems.thermometer, 1), "#", "$", "?", '#', "dyeRed", '$', ModItems.axle, '?', "blockGlass"), "§r§lHELLLOO it's-a-me, bobo! me kNow trik 4 heat! dirt Is much g0od as ins-ool-8-or! hEat relEse power of d1rt! heAt 1et dErP frE!");
		entries.put(new ResourceLocation(Main.MODID, "heat"), new Entry(pages, "Basics of Heat", true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nSteam is best explained by covering fluids in general. Most machines that need fluid can't have it bucketed in directly, and need you to pipe it in. Fluids obviously flow through pipes, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidTube, 8), "###", "   ", "###", '#', "ingotBronze"), "§r§nThese tubes can handle any fluid, hot or cold, and average out the pressure between themselves and stuff around them. Pressure is the amount of liquid divided by the amount it can store. Most machines can only accept or output fluids though, so pipes don't average with those, they just insert/extract. There are also tanks, which store 20 buckets, which can be bucketed in and out of them directly. They average their pressure with tubes, and keep their contents when broken. They're made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidTank, 1), " $ ", "$#$", " $ ", '#', "ingotGold", '$', "ingotBronze"), "§r§r What is the gold for? Surely bronze is enough? You also left out that comparators can detect how full a tank is. §r§nI thought I was supposed to be doing the bit on steam. And the gold is for reinforcement. §r§rGold? Reinforcement? You do know gold is softer than bronze, right? §r§nBe Quiet! You're breaking the fourth wall! §r§rMy bad, I'll just leave and let you get back to spreading misinformation then. §r§nGood ridance. Anyways, steam is just another fluid, and it's only special because it's great for moving energy. Heat can be converted to steam with boilers (more on that later), and steam can be converted back to heat or rotary energy. Also, it flows pretty quickly with no loss, and the tubes don't melt or anything like that. A boiler is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.steamBoiler, 1), "###", "#?#", "&&&", '#', "ingotBronze", '?', "blockBronze", '&', "ingotCopper"), "§r§nA boiler is a bit more complicated than it sounds. Heat goes in the bottom, steam comes out the top, and water goes in the side. The boiler turns water into steam once it hits 110*C. One bucket of steam uses " + Math.round(EnergyConverters.DEG_PER_BUCKET_STEAM * 1.1D) + "*C to create and 1 bucket of water, and 10 pieces of salt are created. Salt can be pulled out the bottom, and if the boiler gets full of salt it stops working. Because salt needs to be hoppered out the bottom and heat goes in the bottom, you can't automate the boiler YET, if you care about that sort of thing for some reason. When you use steam to make rotary energy or heat, you get distilled water back instead of normal water. Distilled water can also be used to make steam, and if you use distilled water no salt is created, making the boiler automateable. Also, the boiler only has to be heated to 100*C, and only uses " + EnergyConverters.DEG_PER_BUCKET_STEAM + "*C per bucket, which is how much heat you can get out of a bucket of steam. Distilled water is just better for making steam for some reason. I don't really know why it takes less heat to boil, maybe the Alchemist could tell you. One last thing in this long ramble, to measure the fluid pressure in something make a fluid guage, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.fluidGauge, 1), "#", "$", '#', Items.COMPASS, '$', ModBlocks.fluidTube));
		entries.put(new ResourceLocation(Main.MODID, "steam"), new Entry(pages, "Basics of Steam", true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe most complicated energy system is rotary. Before I get into specifics, I should explain the physics. Because they are so complicated, I will explain the physics twice: first in a complete way that includes the calculations, and then again in a dumbed down way for people who hate math. Knowing the actual calculations can help optimize rotary systems greatly though. Just skip ahead through this part if you hate math. Gear physics should first be explained with a single gear. Imagine this 1 gear is floating in space, with no friction, AKA no loss. The gear has a mass, and a moment of inertia. A moment of inertia (I) is like mass, but also takes into account the shape of the gear. It is such a pain to calculate that each gear will have the value of I in the tooltip. For a perfect cylinder, I is easy to calculate though: I = R*R*M. Or in plain english, I equals the radius squared times mass. Just assume gears are perfect cylinders when calculating I. The calculations for I outside of perfect shapes involves calculus, but with gears just say they are cylinders. The speed the gear is spinning (in radians per second) is represented by a lowercase omega, w. §r§nThere's no such thing as a lowercase omega. You just wrote a normal W. §r§rYes there is, and they look almost the same. Now leave. Anyways, a radian is a measure of angles, like degrees. There are 2 Pi radians in a circle. The energy in a gear is equal to I*w*w, or I times speed squared. Power is the change in energy every second. Most machines that use rotary energy use it from an attached gear. Most machines will use energy from the gear at a rate determined by the speed. A typical machine (like the grindstone, to be covered in a different section) will have an amount of energy need per operation, a minimum speed, and a maximum speed. They will still work fine above the maximum speed. They will draw all the energy from the gear every tick at or above the maximum speed, will not work at all below the minimum speed, and halfway between the maximum and minimum speed will draw half the energy from the gear every tick. At all speeds it will draw the same amount of energy total, but it runs faster at higher speeds. Now comes gears transmitting energy between each other. Every tick, all gears in a network redistribute energy. A network has a value called V which equals the radius of any gear times the speed of that gear. All gears in a network have the same V. Each gear will have a fraction of the network's energy equal to the fraction of the network's mass that the gear has. So a network of light gears with one heavy gear will result in a higher concentration of energy in the heavier gear. Therefore, putting the heavy gear attached to the machine you want to power will give the machine a bigger bank of energy to draw every tick. Now comes loss: Loss is complicated, and I'll only give you the basics. (Note from the mod author: I made up the loss mechanics for balance reasons.) Every tick, each gear loses a percentage of its energy. The % lost changes based on speed, with higher speeds exponentially increasing loss. Therefore, replaceing heavy gears with lighter gears in a system will likely increase speed but decrease energy. Now for the dumbed down version of gears: Gears spin and more energy means faster spin, but heavier gears means slower spin. Faster spin means faster machines but more energy loss. Heavy gears have less loss. Ok, now for something important whether you hate or love math: Every gear network needs at least one Master Axis with a gear attached to the front. Additional master axises have no effect. Without a Master Axis, nothing will work. They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.masterAxis, 1), "###", "#?#", "#$#", '#', "ingotIron", '?', Blocks.DROPPER, '$', "stickIron"), "§r§rNow for how to make the gears themselves. There are several gear materials, and in order of most to least dense they are: Gold, Copper, Bronze, Iron, & Tin, with gold being more than twice as dense as copper. The two mains types of gears are small gears and large gears. Small gears have a radius of .5 blocks, and 6 can fit in one blockspace. They need to be attached to a solid block. They are made like this, with this particuler recipe making gold ones:", new ShapedOreRecipe(new ItemStack(GearFactory.basicGears.get(GearTypes.GOLD), 8), "***", "*&*", "***", '*', "ingotGold", '&', "blockGold"), "§r§rLarge gears have a radius of 1.5 blocks, and do not need to be supported on something. This recipe makes a gold large gear, but once again they are available in all varieties:", new ShapedOreRecipe(new ItemStack(GearFactory.largeGears.get(GearTypes.GOLD), 1), "***", "*&*", "***", '*', GearFactory.basicGears.get(GearTypes.GOLD), '&', "blockGold"), "§r§rGears can connect around corners, do inside corners, can connect on the same plane, and basically connect in any way that looks logical. One last thing, there are a few tools that help with gears. The hand crank, made like so:", new ShapedOreRecipe(new ItemStack(ModItems.handCrank, 1), " ?", "##", "$ ", '?', Blocks.LEVER, '#', "stickWood", '$', "cobblestone"), "§r§rallows you to manually add energy to gears by cranking them. Right click to spin them one way, shift right click to crank them the other way. Holding down the button is best. Also, a speedometer can measure the speed and energy of a gear, and is made like so:", new ShapedOreRecipe(new ItemStack(ModItems.speedometer, 1), " #", "#$", '#', "string", '$', "ingotIron"), "§r§rOne last trick, if you combine the thermometer, the speedometer, and the fluid guage, you can create an omnimeter which combines all of their functions into one device, which can also give additional information. I highly recommend making one like so:", new ShapedOreRecipe(new ItemStack(ModItems.omnimeter, 1), " # ", "&$%", " ? ", '#', ModItems.fluidGauge, '&', ModItems.thermometer, '$', "gemEmerald", '%', ModItems.speedometer, '?', Items.CLOCK));
		entries.put(new ResourceLocation(Main.MODID, "rotary"), new Entry(pages, "Basics of Rotary", true));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "The Basics", new ItemStack(Item.getByNameOrId("crossroads:oreCopper"), 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// HEAT
		createPages(pages, client, "§r§nThere are a few ways to make heat, but the easiest is to use a coal heater. §r§rI wouldn't call it easiest, cheapest early on maybe, but its not exactly as easily automatable as a heat exchanger. §r§oIye prepher ufther mefhodes purcunally. §r§nYou two and your automation. Not everything has to be automated. §r§rBut at least some things should be. Your idea of enough automation is using the torch trick to collect sand faster. §r§nLook, everything has a place, unless that something is automation. Doing things the hard way is more proper. §r§rBut the hard way is, by definition, harder. §r§nAnd worth it. Now let me talk. A coal heater is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.coalHeater, 1), "#*#", "# #", "###", '#', "cobblestone", '*', "ingotCopper"), "§r§nA Coal Heater can burn coal or charcoal to produce 1600*C per piece. The heat cables can only be connected to the top. §r§oAs you can see by the copper patch on the top. §r§rRemember to be careful with the coal heater before you set up regulatory systems, you don't want to melt the heat cables. Also, the coal heater works as a copper heat cable in that it can move heat between itself and things above it without the aid of a cable.");
		entries.put(new ResourceLocation(Main.MODID, "coalHeater"), new EntryItemStack(pages, "Coal Heater", new ItemStack(ModBlocks.coalHeater, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThe heating chamber is the most obvious and simplest application for heat. It basically acts as a heat powered furnace, though it is faster than a normal furnace. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatingChamber, 1), "#*#", "# #", "###", '#', "ingotIron", '*', "ingotCopper"), "§r§rThe Heating Chamber only works above 200*C, and consumes 100*C to cook one item. Now obviously it is difficult to compare the efficieny of the heating chamber with that of the furnace due to that numerous ways to generate heat, and the fact that the only burnables that can be burned for heat are coal and charcoal, but assuming no loss and that the heating chamber is already pre-heated, 1 coal in a coal heater will produce enough heat to cook 16 items, as opposed to 8 in a furnace. Heat cables can only be connected to the top.");
		entries.put(new ResourceLocation(Main.MODID, "heatingChamber"), new EntryItemStack(pages, "Heating Chamber", new ItemStack(ModBlocks.heatingChamber, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rIf you have already begun working with heat at this point, then you have most likely run into trouble with heat cables melting at high tempertures. The heat exchanger is the solution to that. Heat cables can connect to any side of it other than the bottom. It never melts, and like a heat cable it has loss. Specifically a loss of 0.1. Basically, use it as a heat sink in your heat systems. I would suggest making your main heat system with good conductors, and then using bad conductors like iron to connect to a Heat Exchanger to prevent overheating. Heat exchangers are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatExchanger, 1), "#$#", "$$$", "###", '#', Blocks.IRON_BARS, '$', "ingotCopper"), "§r§rHeat exchangers have one extra ability that when certain things are placed below them they can exchange heat with the block below them and change the block into something else. For example, when the exchanger is below 3000*C, it turns lava below it to cobblestone, and adds 1000* to the heat exchanger. Fire caps at 2000* and adds 300*C, magma blocks turn to netherack, adding 500*C and capping at 2000*C. Snow decreases the temperture by 50*C, with a limit of -20*C, and turns to water. Ice and Packed ice also melt, with ice removing 70*C with a limit of -50*C, and packed ice removing 140*C with a limit of -100*C. There is also another varient of heat exchanger, the insulated heat exchanger which is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.insulHeatExchanger, 1), "###", "#$#", "###", '#', "obsidian", '$', ModBlocks.heatExchanger), "§r§rAn insulated heat exchanger does not lose heat to its surroundings. §r§nWhat's the point of a heat exchanger that doesn't exchange heat? §r§rThe point is that it can still move heat with blocks below them. Therefore, if you wanted to use it for heat generation it is more efficient. A little tip if that is your intention, if you use lava it doesn't have to be a lava source.");
		entries.put(new ResourceLocation(Main.MODID, "heatExchanger"), new EntryItemStack(pages, "Heat Exchangers", new ItemStack(ModBlocks.heatExchanger, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§oShould you need to heat something to a higher temperture then a furnace can reach, a heating crucible will satisfy. It can either heat coblestone into lava or ground copper into molten copper when heated above 1000*C. Insert items through a hopere or other automated method. Pipe the fluid out the sides. Heat it through the bottom. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.heatingCrucible, 1), "# #", "#?#", "###", '#', Blocks.HARDENED_CLAY, '?', Items.CAULDRON), "§r§oThis crucible is crucial to proseccing copper ore. Ite operates faster at higher tempertures, reaching peak efficiency at 1500*C. Every operation creates 200mB of fluid.");
		entries.put(new ResourceLocation(Main.MODID, "heatingCrucible"), new EntryItemStack(pages, "Heating Crucible", new ItemStack(ModBlocks.heatingCrucible, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nThe fluid cooling chamber is a machine with an annoyingly long name. §r§rNonetheless, it's still important. §r§nMaybe. It's the counterpart to the heating crucible. It can cool liquids to produce items. Extract items out the bottom, put fluid in the side, and connect heat cables to the top. When the fluid cooling chamber cools a liquid it creates heat, and if the machine gets above a certain temperture it stops working. It can turn a bucket of lava into obsidian when below 1000*, adding 500* per craft, it can turn 1/5 of a bucket of molten copper into a copper ingot when below 1000*C, adding 100*C per craft, it can turn water into ice when below -10*, adding 1* per craft, and it can turn distilled water into packed ice when below -20*C, adding 2* per craft. It is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fluidCoolingChamber, 1), "###", "# #", "%%%", '#', "ingotTin", '%', "ingotIron"));
		entries.put(new ResourceLocation(Main.MODID, "fluidCooling"), new EntryItemStack(pages, "Fluid Cooling Chamber", new ItemStack(ModBlocks.fluidCoolingChamber, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rOften it is useful to be able to interact with heat cables via redstone. With Redstone Heat Cables, that is possible. They are made by surrounding any heat cable with redstone, like so:", new ShapedOreRecipe(new ItemStack(HeatCableFactory.rCableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL), 1), "###", "#?#", "###", '#', "dustRedstone", '?', HeatCableFactory.cableMap.get(HeatConductors.COPPER).get(HeatInsulators.WOOL)), "§r§rA redstone heat cable functions like a normal heat cable, except it only connects to other heat cables or machines while it has a redstone signal. An omnimeter will tell the user if a heat cable is the redstone variant. A comparator can also be used with a redstone heat cable to measure the temperature. The equation for converting *C to redstone strength is as follows: redstone = 15 * (273 + *C) / (273 + insulator melting point). This equation rounds down. Therefore, this will never reach 15 because at that point the cable melts. ");
		entries.put(new ResourceLocation(Main.MODID, "redstoneCable"), new EntryItemStack(pages, "Redstone Integration-Heat", new ItemStack(Items.REDSTONE, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rIf you need to cool a machine below the ambient biome temperture, such as to create packed ice in a fluid cooling chamber, §r§nI still say it's a stupidly long name. §r§rAnd I don't care. As I Was Saying, should you need to cool something below ambiemt tempertures, I would recommend a salt reactor. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.saltReactor, 1), "#$#", "$%$", "#@#", '#', "ingotTin", '$', ModBlocks.fluidTube, '%', "blockSalt", '@', "ingotCopper"), "§r§rWith a piece of salt and 200mB of distilled water, the salt reactor decreases its temperture by 1* and creates 200mB of normal water. §r§nThat's it? §r§rWhat do you mean that's it? §r§nWhen you said we needed to do the bit on something called a salt reactor, I was expecting something involving radiation that would glow green. Also, 1* isn't very much. §r§rYou do know that the whole concept of radiation glowing green is a misconception, right? And if you use well insulated heat cables, such as ice, 1* is quite a bit. §r§nReally though? Salt to cold. Pretty boring. How does that even work, anyway? §r§oI can answer that. Disolving certain types of salt in water is endothermic. I uses distiled water to be able to disolve more.");
		entries.put(new ResourceLocation(Main.MODID, "saltReactor"), new EntryItemStack(pages, "Salt Reactor", new ItemStack(ModBlocks.saltReactor, 1), true));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Heat Machines", new ItemStack(ModBlocks.heatingChamber, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// ROTARY
		createPages(pages, client, "§r§rThe Grindstone is the first rotary powered machine you should create. Make one like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.grindstone, 1), "#$#", "#?#", "#$#", '#', "cobblestone", '?', "stickIron", '$', Blocks.PISTON), "§r§rThe grindstone has a minimum speed of 0 and a maximum speed of 10. It uses 100 energy total to grind up an item. The grindstone is interesting in that it can be optimized more than usual. You can put a gear on the top AND bottom of the grindstone. When calculating the speed of the attached gears, the grindstone adds together the speeds of the top and bottom gear. If the two gears are spinning in opposite directions, this is beneficial. If they spin in the same direction, this is detrimental. Only one gear is actually neccesary, but due to loss increasing at higher speeds, this allows higher efficiencies with low speeds, reducing energy loss. Of course, items can only be extracted out the bottom, so automation requires the use of only one gear. Items can be inserted into any side other than the bottom. Early on, a hand crank is sufficient to run a grindstone, albeit slowly. The grindstone is the first stage in proccesing copper ore, and the proccesing chain eventually results in two ingots per copper ore. The recipes that the grindstone can do are as follows: Copper Ore -> 2 Copper Dust + 1 Sand, Gravel -> 1 Flint, Bone -> 5 Bonemeal, Coal Block -> 1 Gunpowder, Nether Wart Block -> 9 Netherwart, Wheat -> 3 Seeds, Pumpkin -> 8 Pumpkin Seeds, Melon (slice) -> 3 Melon Seeds. §r§lhOI mE i$ BOBO! musHi mAsh1 p0Tato! iT RAw- me no eAt!");
		entries.put(new ResourceLocation(Main.MODID, "grindstone"), new EntryItemStack(pages, "Grindstone", new ItemStack(ModBlocks.grindstone, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rTranferring items vertically is always a challenge, with hoppers being incapable of the job, dropper chains requiring a timer, and slime blocks often losing items or getting stuck mid launch. However, at the cost of some rotary power, item chutes provide the solution. There are two parts to a chute: the chute itself and the ports. They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.itemChute, 4), "#$#", "#$#", "#$#", '#', "ingotIron", '$', "stickIron"), new ShapelessOreRecipe(new ItemStack(ModBlocks.itemChutePort, 1), ModBlocks.itemChute, Blocks.IRON_TRAPDOOR), "§r§rTo use item chutes, place down a chute port where you want to insert items into the chute automatically. Insert items into the large hole in the port. Put a column of normal Item Chutes from the bottom port up to one block below where you want to get the items out. Put a second chute port on top of the pillar of chutes. Items will be dropped out of the large hole in the top port. Provide the bottom port energy with a gear attached to the small axle hole in the side. Only the bottom port needs power. The chute only operatoes above speeds of .1, and consumes .5 energy per item. A demonstration image is included.", new ResourceLocation(Main.MODID + ":textures/book/chute.png"));
		entries.put(new ResourceLocation(Main.MODID, "itemChute"), new EntryItemStack(pages, "Item Chutes", new ItemStack(ModBlocks.itemChutePort, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Rotary Drill is a block that, when placed down and provided with rotary power, will break blocks and damage mobs in front of it. Make two like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.rotaryDrill, 2), " * ", "*#*", '*', "ingotIron", '#', "blockIron"), "§r§rThe Rotary Drill draws .5 energy from an attached gear on the back every tick, whether it is doing work or not. The drill doesn't use any extra power when doing work. For breaking blocks, it requires a speed of at least .1 times the hardness of the block. For example, cobblestone has a hardness of 3, so a speed of .3 is required. Obsidian on the other hand has a hardness of 50, so to break obsidian the drill has a minimum speed of 5. When damaging mobs, there is no minimum speed, but more speed means more damage. It deals 10 * speed damage, so a speed of 5 deals 50 damage. It deals damage or breaks blocks every half-second.");
		entries.put(new ResourceLocation(Main.MODID, "drill"), new EntryItemStack(pages, "Rotary Drill", new ItemStack(ModBlocks.rotaryDrill, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rBeing able to control gears with redstone can often be useful. The Toggle Gear allows you to connect it and disconnect from machines and other gears with redstone. They are available for all gear materials, and are made like so:", new ShapelessOreRecipe(new ItemStack(GearFactory.toggleGears.get(GearTypes.GOLD), 1), "dustRedstone", "dustRedstone", "stickIron", GearFactory.basicGears.get(GearTypes.GOLD)), "§r§rThey will only connect while they have a redstone signal, so they can be used to split a gear system into two parts (though for both parts to function, both sides need a master axis) or to disconnect a machine. Due to the nature of the mechanism, only one can be fit into a blockspace, and it can only be placed on the ground, not walls or ceilings. It doesn't need to be on a solid block, however. A comparator can also be used to measure the energy of a toggle gear. The equation for signal strength is (signal = 15 * energy / I) rounded down, and limited at 15. Therefore, in order to have a higher measurement range use a gear with a higher value of I. The gear can of course still have more energy than its value of I.");
		entries.put(new ResourceLocation(Main.MODID, "toggleGear"), new EntryItemStack(pages, "Redstone Integration-Rotary", new ItemStack(Items.REDSTONE, 1), true));
		pages = new ArrayList<IPage>();
		
		categories.add(new CategoryItemStack(entries, "Rotary Machines", new ItemStack(GearFactory.basicGears.get(GearTypes.BRONZE), 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// FLUIDS
		createPages(pages, client, "§r§oA way of collecting water into pipes is the rotary pump, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.rotaryPump, 1), "#$#", "#$#", "&$&", '#', "ingotBronze", '&', "blockGlass", '$', "stickIron"), "§r§oThe pump has a minimum speed of .2, ande a maximum speed of 8. Using 200 energy from a gear on top of it, it will draw a fluid source below it into itself, and the fluid can be piped out the sides. Due to it only draining from source blocks directly under it, it is only useful for water. ");
		entries.put(new ResourceLocation(Main.MODID, "rotaryPump"), new EntryItemStack(pages, "Rotary Pump", new ItemStack(ModBlocks.rotaryPump, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rA Steam Turbine is literally just a Rotary Pump with a few minor modifications. It can be converted to and from a Rotary Pump like so:", new ShapelessOreRecipe(new ItemStack(ModBlocks.steamTurbine, 1), ModBlocks.rotaryPump), new ShapelessOreRecipe(new ItemStack(ModBlocks.rotaryPump, 1), ModBlocks.steamTurbine), "§r§rInstead of using rotary energy to pump fluids, a steam turbine creates rotary energy when steam moves through it. Its inputs and outputs are rather complicated, but allow me to explain. The steam turbine has 3 internal tanks, output distilled water, input steam, and output steam. When steam goes into the input steam tank, half of it is converted to distilled water and rotary energy, and the other half moves to the output tank. If eithor of the output tanks fill up, the turbine stops working. The distilled water comes out the side with the red nozzle, the steam goes in the bottom, and waste steam either comes out the orange nozzles or is transmitted to any steam turbines directly on top of the first. Rotary energy is outputted to a gear on top of the turbine, unless the block above is another turbine. In that case, the energy goes to the gear on top of the top turbine in a stack. Therefore, you can create a pillar of turbines with a single gear on top, all feeding their energy into the gear and the waste steam into one another, with the top turbine's waste steam having to be piped out. Use the splitting of steam to control the flow of steam between different machines. It all sounds complicated, but trust me it isn't. One bucket of steam, fully processed into rotary energy, produces " + EnergyConverters.DEG_PER_BUCKET_STEAM / EnergyConverters.DEG_PER_JOULE + " units of energy.");
		entries.put(new ResourceLocation(Main.MODID, "steamTurbine"), new EntryItemStack(pages, "Steam Turbine", new ItemStack(ModBlocks.steamTurbine, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rWhile a Steam Turbine converts steam into rotary energy, a Radiator converts steam into heat. It is also far simpler to use than a Steam Turbine. Insert steam through the bottom and it will fully converted to distilled water and heat. One bucket of steam produces " + EnergyConverters.DEG_PER_BUCKET_STEAM + "*C of heat. Distilled water comes out the top and heat cables can be connected to the sides. A radiator is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.radiator, 1), "#$#", "#$#", "#$#", '#', ModBlocks.fluidTube, '$', "ingotIron"), "§r§lH0I ME IS BOBO! b0Bo teach U ra1n danCe noW! tO do dAnce U ned idol! mE givE U Idol but me lOSe IDOL! U maKe nEw idol like diS! mAgic bLue stuff, roUgh rok, and a taD 'Oh gold rush luCk! hoLd It and Do a BARRAL ROLL! or do rAin dancE to Make THing wOrk! iF U ned dancing les0ns, remembers: The KEY to dancing is STICKY! mAke rAin go aWay by dOing it BackWards! BOBO OUT!");
		entries.put(new ResourceLocation(Main.MODID, "radiator"), new EntryItemStack(pages, "Radiator", new ItemStack(ModBlocks.radiator, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rOften food is not as convenient as it could be. It might not have the exact hunger or saturation value you want, and having a farm for multiple crops be your food source means you have to carry around multiple types of food. Turning food into a liquid sol- §r§oI thought I said that I didn't want to have a bit about that. §r§rWhy, what's wrong with it? §r§nI never heard you say that. §r§oDid I not? Well I meant to. Beceuse it is disgusting is why. Doed this bit without me. §r§rBut you are the only one of us who knows how it works. I know how to use it, but not why it works. You litteraly invented it. §r§oAnd it was a disgusting invention. Goodbye. §r§nWhat exactly is this next device? §r§rLet me talk and you will find out. As I was saying, liquifying food fixes these problems. The first part is makeing food into liquid fat with a Fat Collector, made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fatCollector, 1), "***", "# #", "*&*", '*', "ingotBronze", '#', "netherrack", '&', "ingotCopper"), "§r§rWhen given heat from the bottom and food is inserted into the top, it produces liquid fat, which can be piped out the side. The conversion rate of food value (saturation + hunger) to liquid fat is one value = " + EnergyConverters.FAT_PER_VALUE + "mb of liquid fat. However, the exact temperture of the fat collector matters. Below 100* it does nothing, above 200* it burns up all fat produced, between 140* and 160* is optimal, producing 1.2 times as much liquid fat from food as the normal conversion. From 100* to 140* and from 160* to 200* it is less efficient, producing .8 as much fat from food as the normal conversion. §r§nWait, the purpose of all this is to make liquified fat? Does this get used as food? §r§rYes. §r§nDoesn't sound like it would taste good. §r§rIt really doesn't, but it's efficient. §r§nWhat disgusted the alchemist so much? §r§rPossibly the fact that you end up eating pure fat. As I was saying, the Fat Collector uses .8* per value of the food it converts to liquid fat. Once you get some of this liquid fat, there is another machine that turns it into food that has controllable saturation and hunger. That machine is the Fat Congealer, which is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.fatCongealer, 1), "*^*", "# #", "* *", '*', "ingotBronze", '#', "netherrack", '^', "stickIron"), "§r§rThis machine uses rotary energy from a gear on top of it, and uses liquid fat piped in the side. The exact speed and energy of the gear matters for this machine, as they control the hunger and saturation of the food created. The value of the food created will be equal to the energy of the gear / 10. The saturation of the food will be equal to the (value * speed / 2). The hunger restored is of course value - saturation. The hunger and saturation of the food produced is capped at 20. The machine uses 1 energy per food produced. The food produced is dropped as an item from the bottom of the machine. You can use a hopper to catch it. §r§nExactly what type of food does it make? Some sort of meat or... §r§rEdible blobs of pure fat. §r§nMakes sense. §r§rThe fat congealer uses an amount of liquid fat based on the value of the food and the conversion ratio I mentioned earlier. An example of the math on the Fat Congealer is that a gear on top of it with an energy of 80 and a speed of 1 would produce food with a hunger and saturation value of 4, and would use 800mb of liquid fat.");
		entries.put(new ResourceLocation(Main.MODID, "liquidFat"), new EntryItemStack(pages, "Liquid Fat", new ItemStack(ModItems.edibleBlob, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rSomething that can be useful is the ability to control the flow of fluids with redstone. The Redstone Fluid Tube only allows fluid to flow through it when it has a redstone signal. One is made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.redstoneFluidTube, 1), "***", "*&*", "***", '*', "dustRedstone", '&', ModBlocks.fluidTube));
		entries.put(new ResourceLocation(Main.MODID, "redstoneTube"), new EntryItemStack(pages, "Redstone Integration-Fluids", new ItemStack(Items.REDSTONE), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rDistilled water and salt are often in short supply. Considering the fact that producing them with a steam boiler is not automatable, there is a need for a specialized machine. Thus, the water centrifuge. It is created like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.waterCentrifuge, 1), "*&*", "^%^", "* *", '*', "ingotBronze", '&', "stickIron", '^', ModBlocks.fluidTube, '%', "ingotTin"), "§r§rIt has 4 fluid ports, one on each side. The red ports output distilled water, and the orange ports accept water. Salt can be removed from the bottom. A gear needs to be on top of it. The centrifuge itself takes no energy to run, but that isn't to say that it doesn't have its requirements. The gear on top needs to reach .5 speed for the machine to produce one batch of salt and distilled water. For the next batch, the speed needs to be .5 in the opposite direction. Basically, the direction of the gear on top needs to keep reversing, and each time it needs to reach a speed of at least .5. §r§oHoew byge ys ae batche? §r§r100mB of water is consumed, 100mB of distilled water is produced, and one unit of salt is produced. §r§oThahte duesn't sounde lyke verie muche yf fhe diructyn hase tue bee revehrsede. §r§rProperly automated, it builds up rather quickly.");//TODO
		entries.put(new ResourceLocation(Main.MODID, "waterCentrifuge"), new EntryItemStack(pages, "Water Centrifuge", new ItemStack(ModBlocks.waterCentrifuge), true));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Fluid Machines", new ItemStack(ModBlocks.fluidTube, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		// MISC
		createPages(pages, client, "§r§rIn order that the instructions on processing copper properly are not to be spread thinly throughout various entries, in this entry I will explain the basics of copper proccesing. Native copper ore is found commonly near the surface, and drops 3 copper nuggets when mined. Normal copper ore is also very common, and is only found deeper down. Because you will need a lot of copper, it is imperitive that you learn to process normal copper ore. It cannot be smelted in a normal furnace. First it must be ground in a Grindstone into 2 copper dust. Then the dust must be melted down in a Heating Crucible into molten copper. Finally, molten copper must be run through a Fluid Cooling Chamber to cool it into ingots. When all's said and done, one copper ore will be enough for two copper ingots.");
		entries.put(new ResourceLocation(Main.MODID, "copper"), new EntryItemStack(pages, "Copper Processing", new ItemStack(Item.getByNameOrId(Main.MODID + ":ingotCopper"), 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nA nice thing to have is a Brazier. They are easily made like this:", new ShapedOreRecipe(new ItemStack(ModBlocks.brazier, 1), "###", " $ ", " $ ", '$', "stoneAndesitePolished", '#', "stoneAndesite"), "§r§nA brazier can burn one of two things: charcoal and salt. Put either one in with a right click. §r§rAutomation also works. §r§nNoone cares about your lousy automation. §r§oAye liyke automatci- Aye'll juhst staye outte ofe fhis. §r§nSo you put an item in and it burns for 5 minutes. When an item is burning, particles come out of the brazier and it emits light. §r§rLight level 15 to be exact. §r§nWhat sort of measuring system is that? 15 what, candles? §r§rNot 15 candles, just 15 units. §r§nThat makes no sense. Also, while burning salt there is an additional effect. None of the villager witches can spawn within 64 blocks of a brazier burning salt. §r§oAnd why is that exactly? §r§nBecause salt cleanses things, like false witches. §r§rIf 15 light units doesn't make any sense, then that makes even less sense. §r§nIt just works, OK. §r§lhOI mE 1s BOBO! Burny block do tricks for making stuffs! g0od stuffs! BOBO stuFfs! Burny burny mushy potato for make weak stuffs poison potato for make mega strong stuffs! Toss 3 things onto burny block with potato for new bobo thing! mE tEach you craft now! maKe mega snack too energyful for most peoples, no can control selves. mAke with mushy potatoe on burny block 3 bits are a loaf o' bred, some 'Murica dye, and some glowy dust from H-E-double 1! tHe poweR IT'S OVER 8074! BOBO OUT!");
		entries.put(new ResourceLocation(Main.MODID, "brazier"), new EntryItemStack(pages, "Brazier", new ItemStack(ModBlocks.brazier, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rThis section will cover two devices: the sorting hopper and the slotted chest. On their own, neither of these things are so incredible, but when combined they are very convenient. They are made like so:", new ShapedOreRecipe(new ItemStack(ModBlocks.sortingHopper, 1), "# #", "#&#", " # ", '#', "ingotCopper", '&', "chestWood"), new ShapedOreRecipe(new ItemStack(ModBlocks.slottedChest, 1), "###", "$@$", "###", '#', "slabWood", '$', Blocks.TRAPDOOR, '@', "chestWood"), "§r§rThe Sorting Hopper functions almost identically to a normal hopper but for a suble difference that has huge ramifications. While a normal hopper processes extracting items after inserting them, the sorting hopper processes extracting items before inserting them. The reason this is importan is that if you make a pillar of sorting hoppers, with them all facing sideways into inventories, then items go into the top inventory first, then the second inventory, and so on. This does not occur with normal hoppers. This means you can filter items. If the top inventory can only accept sand and the middle one accepts only dirt and the bottom one takes anything, then putting dirt, sand, and gravel into the top hopper will result in all the sand going into the top inventory, all the dirt going into the middle inventory, and all the gravel going into the bottom inventory. The Slotted Chest is a chest the size of a double chest, and it has a very interesting quirk. You might notice when using it that you can't shift click item into it, and when removing items from the slotted chest it leaves a sort of ghost item behind? You can shift click into the slotted chest, but only if the slot the items are going to already has the matching item. To clear a ghost item, shift click it with an empty cursor. Also, automation will respect the ghost items, only being able to insert into a slot if it already has a match and when extracting items, always leaving a ghost item behind. This allows you to format your storage chests fear of shift clicks or automation messing it up. I assume that at this point you see how the slotted chest and sorting hopper complement each other? Therefore, you can now have automated sorting systems that puts the stone in the blocks chest, the diamonds in the valuables chest, the wood in the blocks chest, and so on. §r§oHolde oen. Doehn't youe meane woode goese intoe fhe plantes chest? §r§rNo of course not, if I put logs there then I'd have to put planks there, and chests there, and pretty soon I'd be putting tripwire hooks in the plants chest. §r§oNoe, the tripewhire hookes goe intoe fhe teknology cheste. §r§rYou really put wood in the plants chest? What's next, putting coal in the plants chest becuase it used to be plants 100 million years ago? §r§oDoen't bee ridyculous, coale goese intoe fhe burnabels cheste. §r§rYou make a burnables chest? Then why don't you put wood in it? §r§oBecause woulde ys notte fore fuele, it ys fore ofher thyngs. Doe youe putte caktus yn the blockes cheste, yt's a blocke? §r§rNow you're just mocking me. Witch, you decide. Does wood go into blocks or plants? §r§nI don't bother sorting, I just stick stuff in random chests for later. §r§oWhahte? Howe doe youe fynd anyfhing? §r§nI just remember where stuff is. There's no need to be OCD like you two. §r§rAt least we don't end up spending half our time looking for things. §r§lhOI me iS BOBO! dem peoples go on and on about some copper hopper for ever. copper hopper rhymes! COPPER HOPPER COPPER HOPPER COPPPER HOPPPER! Me know trick with hopper. It not copper hopper though. Me make vaccuum hopper, it useful for everything! getting sTuff, flying, herding cats, everything! Just one funnel, a sheep's coat, or maybe jacket, and a tube! BOBO OUT!");
		entries.put(new ResourceLocation(Main.MODID, "itemSorting"), new EntryItemStack(pages, "Sorting Devices", new ItemStack(ModBlocks.sortingHopper, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nBecause mining obsidian is the most painful thing in the universe, I'll tell you how to make it easier. Once you get your first piece of obsidian, you can use it to create 4 obsidian cutting kits like so:", new ShapedOreRecipe(new ItemStack(ModItems.obsidianKit, 4), " # ", "#$#", " # ", '$', "obsidian", '#', Items.FLINT), "§r§nSimply right click it on some obsidian to insta-mine the obsidian and destroy the cutting kit. I find it's very convenient for getting lots of obsidian.");
		entries.put(new ResourceLocation(Main.MODID, "obCutting"), new EntryItemStack(pages, "Obsidian Cutting Kits", new ItemStack(ModItems.obsidianKit, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§nSometimes after a long day of working hard and building technology, you just want to relax in a pretty area. A few nice things for decorating with ar- §r§rFew? It's one thing. §r§nI'll come up with more things later! Anyways, the very nice decoration I came up with was the Candle Lilypad. It's a nice looking lilypad with a candle on it, and it gives off light. Just make it like this:", new ShapelessOreRecipe(new ItemStack(ModBlocks.candleLilyPad), Blocks.WATERLILY, "torch"), "§r§lhOI me is BOBO! me know things! l1lyPads is plant and chicken eat plant so chicken + lilypad equal LUMINATI! oH yEah! & m1x dem too things with a bit of cow for da mega thing!");
		entries.put(new ResourceLocation(Main.MODID, "decorative"), new EntryItemStack(pages, "Decorative Blocks", new ItemStack(ModItems.itemCandleLilypad, 1), true));
		pages = new ArrayList<IPage>();
		createPages(pages, client, "§r§rJust a quick note, should you manage to obtain any metal scraps, possibly by blowing up delicate metal devices *cough*gears*cough*, you can still find a use for them. Use them to make axles and save iron. Do that like so:", new ShapedOreRecipe(new ItemStack(ModItems.axle, 1), "#", "?", "#", '#', Blocks.STONE, '?', ModItems.metalScrap));
		entries.put(new ResourceLocation(Main.MODID, "metalScrap"), new EntryItemStack(pages, "Misc Metal Scraps", new ItemStack(ModItems.metalScrap, 1), true));
		pages = new ArrayList<IPage>();

		categories.add(new CategoryItemStack(entries, "Miscellaneous", new ItemStack(ModBlocks.brazier, 1)));
		entries = new LinkedHashMap<ResourceLocation, EntryAbstract>();

		main.setTitle("Main Menu");
		main.setWelcomeMessage("Welcome to Crossroads");
		main.setDisplayName("mysteriousJournal");
		main.setColor(Color.GRAY);
		main.setCategoryList(categories);
		main.setRegistryName("crossroadsMainGuide");
		main.setSpawnWithBook(true);

		GuideAPI.BOOKS.register(main);
	}

	/**
	 * Splits up a long string into pages. I can't use PageHelper for this
	 * because of the § symbol.
	 * 
	 */
	private static void createTextPages(ArrayList<IPage> pages, String text, boolean client){

		final int PERPAGE = 350;

		char symbol = 167;
		String format = "";
		String snip = "";

		final double ILIMIT = Math.ceil((double) (text.replaceAll("§r§r", "").replaceAll("§r§n", "").replaceAll("§r§o", "").replaceAll("§r§l", "").length()) / PERPAGE);
		for(int i = 0; i < ILIMIT; ++i){
			String chunk = text.substring(i * PERPAGE, (i == ILIMIT - 1) ? (text.length() % PERPAGE) + i * PERPAGE : (i + 1) * PERPAGE);

			pages.add(new PageText(format + snip + (i == ILIMIT - 1 ? chunk : chunk.substring(0, chunk.lastIndexOf(" ")))));

			if(client){
				((Page) pages.get(pages.size() - 1)).setUnicodeFlag(true);
			}

			snip = chunk.substring(chunk.lastIndexOf(" ") + 1);

			int marker = (text.substring(0, i == ILIMIT - 1 ? (text.length() % PERPAGE) + i * PERPAGE : (i + 1) * PERPAGE)).lastIndexOf(symbol);
			format = text.substring(marker - 2, marker + 2);

		}
	}

	private static void createPages(ArrayList<IPage> pages, boolean client, Object... parts){
		for(Object obj : parts){
			if(obj instanceof String){
				createTextPages(pages, (String) obj, client);
			}else if(obj instanceof ItemStack){
				pages.add(new PageFurnaceRecipe((ItemStack) obj));
			}else if(obj instanceof ResourceLocation){
				pages.add(new PageImage((ResourceLocation) obj));
			}else if(obj instanceof IRecipe){
				pages.add(new PageIRecipe((IRecipe) obj));
			}else{
				System.err.println("CROSSROADS: ERROR WRITING TO THE JOURNAL, REPORT TO MOD AUTHOR");
			}
		}
	}

}
